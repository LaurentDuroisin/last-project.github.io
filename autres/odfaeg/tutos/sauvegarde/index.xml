<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre XII : Le système de sauvegarde de odfaeg.</h1>

               		<h2>La sauvegarde d'entités simple : </h2>


<p>
Pour sérialiser des données il faut deux choses. (une archive qui contiendra le flux <br/>
dans lequel on mettra les données, ainsi que le flux bien sur) <br/>
Pour le moment odfaeg gère 2 types d'archives : une pour l'écriture (OTextArchive) et une <br/>
pour la lecture. (ITextArchive) <br/>
Mais plus tard il est fort possible que j'incorpore d'autres types d'archive comme par <br/>
exemple les archives binaires ou bien les archives au format xml. <br/>

Il faut donc créer un objet de ce type en lui passant un flux, par exemple, un fichier : <br/>
</p>

<p>
Ensuite pour sérialiser il suffit d'appeler l'opérateur () sur l'archive en lui passant l'objet, <br/>
ici par exemple nous allons sérialiser un objet de type std::string :

<pre>
ofstream ofs("thefile");
OTextArchive oa (ofs);

std::string text="blablabla";
    std::string text2;
    std::ofstream ofs("FichierDeSerialisation");
    {
        odfaeg::OTextArchive oa(text);
        oa(text);
    }
    ofs.close();
    
</pre>

Pour la lecture le code est similaire à part que l'on utilise les classe ifstream et ITextArchive :

<pre>
std::ifstream ifs("FichierDeSerialisation");
{
    odfaeg::ITextArchive ia(ifs);
    ia(text2); 
}
std::cout&lt;&lt;text2&lt;&lt;std::endl;
ifs.close();
</pre>
</p>

<p>
Pour sérialiser vos objets personnels, il suffit de redéfinir la méthode serialize dans la classe et <br/>
de passer à l'archive toutes les variables de la classe.<br/>


<pre>
struct A {
    A() {
        var = 10;
    }
        void foo(int i)
        { std::cout&lt;&lt;i; }
        template &lt;typename A&gt;
        void serialize (A &amp; ar) {
           ar(var);
        }
        int var;
};

</pre>
</p>

<p>
Car c'est cette méthode que odfaeg va rechercher pour sérialiser l'objet dans l'archive, le br/> 
code pour sérialiser l'objet dans le main est le même que pour les objets de types std::string. <br/>

Cette manière de faire est simple mais ne fonctionnera pas dans le cadre des objets <br/>
polymorphique, en effet, quel donnée de l'objet faut t'il sérialiser, les données de la <br/> 
classe de base seulement, ou celles de la classe dérivée seulement, ou bien les deux ? <br/>

Par défaut odfaeg ne sérialize que les données de la classe de base.<br/>
</p>

<p>
Pour lui dire de sérialiser les données de la classe dérivée, il faut redéfinir une <br/> 
autre méthode : la méthode vtserialize. <br/>

Pour serializer un objet odfaeg utilise une classe dont il faut hériter dans la classe de <br/>
base comme ceci : <br/>
struct B : public Registered&lt;B&gt; <br/>
</p>

<p>
La classe de base doit au moins avoir une méthode virtuelle pour pouvoir être considérée <br/> 
comme une classe polymorphique, car, odfaeg fait le test à l'exécution avec typeid, <br/> 
et l'héritage doit être pulibque! (Sinon ça ne fonctionnera pas) <br/>
<pre>
struct B : public Registered&lt;B&gt; {
    B() {
       c = "serialize base";
    }
    virtual void foo()
    { std::cout&lt;&lt;1; }
    virtual void print() {
      std::cout&lt;&lt;c&lt;&lt;std::endl;
    }
    template &lt;typename A&gt;
    void vtserialize (A &amp; ar) {
       ar(c);
    }
    virtual ~B();
    std::string c;  
};
B::~B(){}
</pre>
</p>

<p>
Registered n'est rien d'autre qu'un objet qui va savoir comment sérialiser l'objet <br/> 
polymorphique, on doit lui passer en paramètre template la classe de Base.<br/>
Ensuite il ne faut pas oublié de redéfinir la méthode virtuelle template vtserialize dans <br/>
la classe dérivée. <br/>
</p>

<p>
<pre>
struct C : B {
    C () {
        c = "serialize derived";
    }
    void foo();
    void print () {
        B::print();
        std::cout&lt;&lt;c&lt;&lt;std::endl;
    }
    template &lt;typename A&gt;
        void vtserialize (A &amp; ar) {
           B::vtserialize(ar);
           ar(c);
        }
        std::string c;
};

void C::foo(){ std::cout &lt;&lt; 2; }
</pre>
</p>
<p>
Mais ce n'est pas tout, odfaeg sait comment sérialiser les objets polymorphiques, c'est grâce à la classe<br/>
Registred héritée par la classe de base qu'il sait qu'il doit aussi sérialiser les attributs de la classe dérivée.<br/>

Mais il ne sait pas quelle fonction de la classe dérivé il doit appeler pour sérialiser les données <br/>
ni quel allocateur utiliser pour allouer les pointeurs sur les types de base pour les objets des classes dérivées<br/>
, pour lui dire, il faut appeler la macro EXPORT_CLASS_GUID dans la fonction main et lui passer 3 paramètres! <br/>
</p>

<p>
Le 1er paramètre est un id qui doit être unique pour chaque exportation, car on peut très bien avoir plusieurs <br/>
classes dérivées pour une même classe de base, ou bien même avoir des classes dérivées qui héritent <br/>
de plusieurs classe de base! (héritage multiple) <br/>

Le second paramètre est le type de la classe de base dont hérite la classe Dérivée. <br/>

Et le dernier paramètre est le type de la classe dérivée à exporter, ce qui donne le code final suivant : <br/>

<pre>
struct B : public odfaeg::Registered&lt;B&gt; {
    B() {
        c = "serialize base";
    }
    virtual void foo()
    { std::coutlt;&lt;1; }
    virtual void print() {
    std::cout&lt;&lt;c&lt;&lt;std::endl;
    }
    template &lt;typename A&gt;
    void vtserialize (A &amp; ar) {
    ar(c);
    }
    virtual ~B();
    std::string c;      
};
 
B::~B(){}
 
struct C : B {
    C () {
        c = "serialize derived";
    }
    void foo();
    void print () {
        B::print();
        std::cout&lt;&lt;c&lt;&lt;std::endl;
    }
    template &lt;typename A&gt;
        void vtserialize (A * ar) {
        B::vtserialize(ar);
        ar(c);
        }
        std::string c;
};
void C::foo(){ std::cout&lt;&lt;2; }
int main() {    
    EXPORT_CLASS_GUID(BC, B, C)
    C c;
    B* b = &amp;c;
    B* b2;
    std::ofstream ofs("FichierDeSerialisation");
    odfaeg::OTextArchive oa(ofs);
    oa(b);
    std::ifstream ifs("FichierDeSerialisation");
    odfaeg::ITextArchive ia(ifs);
    ia(b2);
    b2->print();
}
</pre>
</p>
                </html>
        </fr>
        <en>
            <html>
                <h1>The backup system of ODFAEG</h1>
                <h2>How to register simple entities.</h2>
                <p>
                To serialize entities, you need to have two things : <br/>
                An archive : (This one'll contains the text which'll be registered into a stream)<br/>
                The stream itself : this is just an archive containing the stream.<br/>
                At the moment, odfaeg manage two types of archives : <br/>
                OTextArchive for the writing, and ITextArchive for the reading.<br/>
                But later, this is possible that I implement others archives formats.<br/>
                Then, you have juste to pass the object to serialise to the archive by calling the functor : <br/>
                <pre>
                    ofstream ofs("thefile");
                    OTextArchive oa (ofs);
                    
                    std::string text="blablabla";
                        std::string text2;
                        std::ofstream ofs("FichierDeSerialisation");
                        {
                            odfaeg::OTextArchive oa(text);
                            oa(text);
                        }
                        ofs.close();
                </pre>
                </p>
                <p>
                For the reading, the code is similar, you just need to use the classes ifstream and ITextArchive.<br/>
                <pre>
                    std::ifstream ifs("FichierDeSerialisation");
                    {
                        odfaeg::ITextArchive ia(ifs);
                        ia(text2); 
                    }
                    std::cout&lt;&lt;text2&lt;&lt;std::endl;
                    ifs.close();
                </pre>
                To serialize your personal objects, you just need to redefine the serialize method, <br/>
                this method take a parameter : the archive.<br/>
                <pre>
                    struct A {
                        A() {
                            var = 10;
                        }
                            void foo(int i)
                            { std::cout&lt;&lt;i; }
                            template &lt;typename A&gt;
                            void serialize (A &amp; ar) {
                               ar(var);
                            }
                            int var;
                    };
                </pre>
                </p>
                <p>
                Because this is this method that ODFAEG'll research to serialize the data of your object into<br/>
                the stream of the archive.<br/>
                The code to serialize the object onto the main is just the same than the code above which serialize a std::string<br/>
                This way of doing is simple, but not sufficient for polymorphic objets.<br/>
                by default odfaeg'll serialize only the data of the base class, but, maybe you'll need to <br/>
                also serialize the data of the subclass, or of both.<br/>
                To serialize data of the derived class, you'll need to redefine a new method : the method vtserialize.<br/>
                The base class must always have a virtual method to be considered as a polymorphic class.<br/>
                Because odfaeg perform a test with typeid at the execution.<br/>
                And the inheritence must be public!<br/>
                <pre>
                    struct B : public Registered&lt;B&gt; {
                        B() {
                           c = "serialize base";
                        }
                        virtual void foo()
                        { std::cout&lt;&lt;1; }
                        virtual void print() {
                          std::cout&lt;&lt;c&lt;&lt;std::endl;
                        }
                        template &lt;typename A&gt;
                        void vtserialize (A &amp; ar) {
                           ar(c);
                        }
                        virtual ~B();
                        std::string c;  
                    };
                    B::~B(){}
                </pre>
                Registered is nothing else than an object which know how to serialize the polymorphic objects.<br/>
                It attempts a template parameter : the base object type.<br/>
                The method template vtserialize, have to be redefined in a subclass.<br/>
                
                </p>
                <p>
                <pre>
            struct C : B {
                C () {
                    c = "serialize derived";
                }
                void foo();
                void print () {
                    B::print();
                    std::cout&lt;&lt;c&lt;&lt;std::endl;
                }
                template &lt;typename A&gt;
                    void vtserialize (A &amp; ar) {
                       B::vtserialize(ar);
                       ar(c);
                    }
                    std::string c;
            };
            
            void C::foo(){ std::cout &lt;&lt; 2; }
            </pre>
            But that's not all, odfaeg knows that he must serialize the data of your polymoprhic object, but<br/>
            doesn't know how which method to use to register them.<br/>
            To do that, you just have to call the EXPORT_CLASS_GUI macro, which attempts three parameters :
            The first one is the name of the relation.<br/>
            The second is the name of the base class.<br/>
            And the last one is the name of the subclass.<br/>
            Here is the complete code so to serialize our object.<br/>
            <pre>
                struct B : public odfaeg::Registered&lt;B&gt; {
                    B() {
                        c = "serialize base";
                    }
                    virtual void foo()
                    { std::coutlt;&lt;1; }
                    virtual void print() {
                    std::cout&lt;&lt;c&lt;&lt;std::endl;
                    }
                    template &lt;typename A&gt;
                    void vtserialize (A &amp; ar) {
                    ar(c);
                    }
                    virtual ~B();
                    std::string c;      
                };
                 
                B::~B(){}
                 
                struct C : B {
                    C () {
                        c = "serialize derived";
                    }
                    void foo();
                    void print () {
                        B::print();
                        std::cout&lt;&lt;c&lt;&lt;std::endl;
                    }
                    template &lt;typename A&gt;
                        void vtserialize (A * ar) {
                        B::vtserialize(ar);
                        ar(c);
                        }
                        std::string c;
                };
                void C::foo(){ std::cout&lt;&lt;2; }
                int main() {    
                    EXPORT_CLASS_GUID(BC, B, C)
                    C c;
                    B* b = &amp;c;
                    B* b2;
                    std::ofstream ofs("FichierDeSerialisation");
                    odfaeg::OTextArchive oa(ofs);
                    oa(b);
                    std::ifstream ifs("FichierDeSerialisation");
                    odfaeg::ITextArchive ia(ifs);
                    ia(b2);
                    b2->print();
                }
            </pre>
            </p>
            and that's it, this is how the powerfull backup system of odfaeg works!<br/>
            </html>
        </en>
    </content>
</page>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre XI : La gestion des collisions.</h1>

               		<h2>La méthode simple : </h2>

<p>La méthode simple consiste à récupérer la cellule de la grille du monde à un endroit, et <br/> 
de faire en sorte que le joueur ne puisse pas passer sur cette case comme ceci : <br/>

World::getGridCellAt(Vec2f(x, y))->setPassable(false); <br/>
</p>

<h2>Une méthode plus précise : </h2>

<p>
Faire les collisions sur les cases de la grille peut ne pas être très précis, odfaeg <br/> 
permet également d'associer à chaque entité une hiérarchie de volumes englobants, c'est à <br/> 
dire que tout comme les entités, les volumes englobant peuvent contenir des volumes <br/> 
englobants enfants, le test de collision se fera alors sur les volumes englobant <br/>
enfant si le volume englobant parent est en collision avec celui d'une autre entité du monde. <br/>
Voici un exemple de code qui ajoute un volume de collision à une entité, par défaut les <br/>
entités n'ont pas de volume de collision. <br/>

<pre>
 odfaeg::physic::BoundingVolume *bb = new odfaeg::BoundingBox(decor->getGlobalBounds().getPosition().x, 
            decor->getGlobalBounds().getPosition().y + decor->getGlobalBounds().getSize().y * 0.4f, 0,
            decor->getGlobalBounds().getSize().x, decor->getGlobalBounds().getSize().y * 0.25f, 0);
            decor->setCollisionVolume(bb);
</pre>
</p>
Ici je met 0 pour la position en z et la profondeur car on est en 2D.
<p>
odfaeg possède actuellement 5 types de volumes englobant pouvant s'imbriquer les uns <br/> 
dans les autres : <br/>
BoundingBox : une boîte alignée avec les axes x, y et z. <br/>
OrientedBoundingBox : une boîte orientée. (Peut s'orienté avec la rotation du modèle) <br/>
BoundingSphere : une sphere. <br/>
BoundingEllipsoid : une éllipsoïde. (Peut s'orienté avec la rotation du modèle) <br/>
BoundingPolyhedron : un polygône convexe. (Peut s'orienté avec la rotation du modèle) <br/>
</p>

<h2>Tester les collisions : </h2>

<p>
afin de tester la collision, il suffit d'appeler la fonction collide de la classe World <br/>
en lui passant l'entité sur laquelle on veut tester la collision : <br/>

<pre>
//Si il y a collision, on revient en arrière.
if (World::collide(caracter)) {
        World::moveEntity(caracter, -caracter->getDir().x * t, -caracter->getDir().y * t);
        getView().move(-caracter->getDir().x * t, -caracter->getDir().y * t, 0);
}
</pre>
</p>

<p>
Ici, si l'entité est en collision avec une case ou une autre entité dans le monde, on <br/> 
annule le déplacement de l'entité. <br/>
</p>

<h2>Le système de particules : </h2>

<p>
Celui-ci est for similaire à celui de la thor library donc vous pouvez dans un premier temps de lire les tutoriels de la <br/> 
librairie thor : <br/>

<a href="http://www.bromeon.ch/libraries/thor/v2.0/tutorial-particles.html">THOR</a>

La seule différence est que les particules sont dessinées sur un billboard, ce n'est rien d'autre qu'un sprite orienté vers la caméra. <br/>
Voici un exemple de code source qui émet 30 particules par seconde, qui ont une durée de vie de 5 à 7 secondes, <br/>
Apparaissant aléatoirement dans le rectangle de centre 50, 90, 0 et de demi taille 25, 5, 0, et enfin, ayant -10 de force.<br/>
Les particules vont donc s'envoler vu que elles ont une force négative.<br/>
Les particules utilisent un "texture rect" au hasard sur une texture.<br/>
<pre>
    billboard = new BillBoard(getView());
    billboard->getParticleSystem().setTexture(*tm.getResourceByAlias("PARTICLE"));
    for (unsigned int i = 0; i &lt; 10; i++) {
        billboard->getParticleSystem().addTextureRect(sf::IntRect(i*10, 0, 10, 10));
    }
    emitter.setEmissionRate(30);
    emitter.setParticleLifetime(Distributions::uniform(sf::seconds(5), sf::seconds(7)));
    emitter.setParticlePosition(Distributions::rect(Vec3f(50, 90, 0), Vec3f(25, 5, 0)));   
    // Emit particles in given circle
    emitter.setParticleVelocity(Distributions::deflect(Vec3f(0, -10, 0),  0)); 
    // Emit towards direction with deviation of 0°
    emitter.setParticleRotation(Distributions::uniform(0.f, 0.f));
    emitter.setParticleTextureIndex(Distributions::uniformui(0, 9));
    emitter.setParticleScale(Distributions::rect(Vec3f(2.1f, 2.1f, 1.f), Vec3f(2.f, 2.f, 2.f)));
</pre>
</p>
Lors du dessin, il faut récupérer la tile (le billboard) et la dessiner, les billboard portent le tag "E_BILLBOARD" :
<pre>
std::vector&lt;Entity*&gt; particles = World::getVisibleEntities("E_BILLBOARD");
for (unsigned int i = 0; i &lt; particles.size(); i++)
    window->draw(*particles[i]);
</pre>
Pour supprimer un émitteur explicitement, il faut appeler la méthode removeEmmiter de la classe system, même chose pour<br/>
les affectors.<br/>
<p>
Vous trouverez dans les démos plusieurs exemples de code source qui utilise le moteur<br/> 
jusqu'ici et qui montre déjà ce que le framework propose de faire, mais ce n'est que le<br/> 
commancement car je suis encore assez loin comparé à d'autres projets déjà existant.<br/>
</p>
                </html>
        </fr>
    </content>
</page>

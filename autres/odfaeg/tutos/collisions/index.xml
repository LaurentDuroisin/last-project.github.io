<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre XI : La gestion des collisions.</h1>

               		<h2>La méthode simple : </h2>

<p>La méthode simple consiste à récupérer la cellule de la grille du monde à un endroit, et <br/> 
de faire en sorte que le joueur ne puisse pas passer sur cette case comme ceci : <br/>

World::getGridCellAt(Vec2f(x, y))->setPassable(false); <br/>
</p>

<h2>Une méthode plus précise : </h2>

<p>
Faire les collisions sur les cases de la grille peut ne pas être très précis, odfaeg <br/> 
permet également d'associer à chaque entité une hiérarchie de volumes englobants, c'est à <br/> 
dire que tout comme les entités, les volumes englobant peuvent contenir des volumes <br/> 
englobants enfants, le test de collision se fera alors sur les volumes englobant <br/>
enfant si le volume englobant parent est en collision avec celui d'une autre entité du monde. <br/>
Voici un exemple de code qui ajoute un volume de collision à une entité, par défaut les <br/>
entités n'ont pas de volume de collision. <br/>

<pre>
 odfaeg::physic::BoundingVolume *bb = new odfaeg::BoundingBox(decor->getGlobalBounds().getPosition().x, 
            decor->getGlobalBounds().getPosition().y + decor->getGlobalBounds().getSize().y * 0.4f, 0,
            decor->getGlobalBounds().getSize().x, decor->getGlobalBounds().getSize().y * 0.25f, 0);
            decor->setCollisionVolume(bb);
</pre>
</p>
Ici je met 0 pour la position en z et la profondeur car on est en 2D.
<p>
odfaeg possède actuellement 5 types de volumes englobant pouvant s'imbriquer les uns <br/> 
dans les autres : <br/>
BoundingBox : une boîte alignée avec les axes x, y et z. <br/>
OrientedBoundingBox : une boîte orientée. (Peut s'orienté avec la rotation du modèle) <br/>
BoundingSphere : une sphere. <br/>
BoundingEllipsoid : une éllipsoïde. (Peut s'orienté avec la rotation du modèle) <br/>
BoundingPolyhedron : un polygône convexe. (Peut s'orienté avec la rotation du modèle) <br/>
</p>

<h2>Tester les collisions : </h2>

<p>
afin de tester la collision, il suffit d'appeler la fonction collide de la classe World <br/>
en lui passant l'entité sur laquelle on veut tester la collision : <br/>

<pre>
//Si il y a collision, on revient en arrière.
if (World::collide(caracter)) {
        World::moveEntity(caracter, -caracter->getDir().x * t, -caracter->getDir().y * t);
        getView().move(-caracter->getDir().x * t, -caracter->getDir().y * t, 0);
}
</pre>
</p>

<p>
Ici, si l'entité est en collision avec une case ou une autre entité dans le monde, on <br/> 
annule le déplacement de l'entité. <br/>
</p>

<h2>Le système de particules : </h2>

<p>
Celui-ci est for similaire à celui de la thor library donc vous pouvez dans un premier temps de lire les tutoriels de la <br/> 
librairie thor : <br/>

<a href="http://www.bromeon.ch/libraries/thor/v2.0/tutorial-particles.html">THOR</a>

La seule différence est que les particules sont dessinées sur un billboard, ce n'est rien d'autre qu'un sprite orienté vers la caméra. <br/>
Voici un exemple de code source qui émet 30 particules par seconde, qui ont une durée de vie de 5 à 7 secondes, <br/>
Apparaissant aléatoirement dans le rectangle de centre 50, 90, 0 et de demi taille 25, 5, 0, et enfin, ayant -10 de force.<br/>
Les particules vont donc s'envoler vu que elles ont une force négative.<br/>
Les particules utilisent un "texture rect" au hasard sur une texture.<br/>
<pre>
    billboard = new BillBoard(getView());
    billboard->getParticleSystem().setTexture(*tm.getResourceByAlias("PARTICLE"));
    for (unsigned int i = 0; i &lt; 10; i++) {
        billboard->getParticleSystem().addTextureRect(sf::IntRect(i*10, 0, 10, 10));
    }
    emitter.setEmissionRate(30);
    emitter.setParticleLifetime(Distributions::uniform(sf::seconds(5), sf::seconds(7)));
    emitter.setParticlePosition(Distributions::rect(Vec3f(50, 90, 0), Vec3f(25, 5, 0)));   
    // Emit particles in given circle
    emitter.setParticleVelocity(Distributions::deflect(Vec3f(0, -10, 0),  0)); 
    // Emit towards direction with deviation of 0°
    emitter.setParticleRotation(Distributions::uniform(0.f, 0.f));
    emitter.setParticleTextureIndex(Distributions::uniformui(0, 9));
    emitter.setParticleScale(Distributions::rect(Vec3f(2.1f, 2.1f, 1.f), Vec3f(2.f, 2.f, 2.f)));
</pre>
</p>
Lors du dessin, il faut récupérer la tile (le billboard) et la dessiner, les billboard portent le tag "E_BILLBOARD" :
<pre>
std::vector&lt;Entity*&gt; particles = World::getVisibleEntities("E_BILLBOARD");
for (unsigned int i = 0; i &lt; particles.size(); i++)
    window->draw(*particles[i]);
</pre>
Une autre différence également : pour supprimer un émitteur explicitement, il faut appeler la méthode removeEmmiter de la classe system, même chose pour<br/>
les affectors.<br/>
<p>
Vous trouverez dans les démos plusieurs exemples de code source qui utilise le moteur<br/> 
jusqu'ici et qui montre déjà ce que le framework propose de faire, mais ce n'est que le<br/> 
commancement car je suis encore assez loin comparé à d'autres projets déjà existant.<br/>
</p>
                </html>
        </fr>
        <en>
            <html>
                <h1>Management of collisions.</h1>
                <h2>The simple method.</h2>
                <p>
                The simple method consist of getting the cell of the grid at a place, set up.<br/>
                a booleen to false, so, the caracter'll not be able to pass throught this cell.<br/>
                </p>
                <h2>A more accurate method.</h2>
                <p>
                Setting the collisions on the grid cell's may not be very accurate, odfaeg also allow you<br/>
                to associate to each entity, a bounding volume.<br/>
                bounding volumes can also have children like entities.<br/>
                The collision test happen in two phase, the narrow phase, and the broad phase :
                <br>The broad phase : it checks every entities of the grid cells which are located into the</br>
                entity's position.<br/>
                <br>The narrow phase : it check if the bouding volumes of the entity, and of the entities around are</br>
                in collision.<br/>
                <pre>
                    odfaeg::physic::BoundingVolume *bb = new odfaeg::BoundingBox(decor->getGlobalBounds().getPosition().x, 
                    decor->getGlobalBounds().getPosition().y + decor->getGlobalBounds().getSize().y * 0.4f, 0,
                    decor->getGlobalBounds().getSize().x, decor->getGlobalBounds().getSize().y * 0.25f, 0);
                    decor->setCollisionVolume(bb);
                </pre>
                Here I set 0 for the z position because we are in 2D.<br/>
                odfaeg have actually 5 types of bounding volumes which can be imbricked.<br/>
                BoundingBox = an axis aligned bounding box.<br/>
                OrientedBoundingBox = an oriented axis bounding box. (can be oriented with the model)<br/>
                BoundingSphere = a bounding sphere.<br/>
                BoundingEllipsoid = a bounding ellpsoid. (can be oriented with the model)<br/>
                BoundingPolyhedron = a bounding convex polyhedron.(can be oriented with the model) <br/>
                <pre>
                    //If there is a collision, we go back.
                    if (World::collide(caracter)) {
                            World::moveEntity(caracter, -caracter->getDir().x * t, -caracter->getDir().y * t);
                            getView().move(-caracter->getDir().x * t, -caracter->getDir().y * t, 0);
                    }
                </pre>
                </p>
                <h2>The particule system.</h2>
                <p>
                    This oe is very similar to the one of the thor library, so, I recommand you <br/>
                    to read the tutorials of this library : <a href="http://www.bromeon.ch/libraries/thor/v2.0/tutorial-particles.html">THOR</a><br/>
                    The only difference if that the particles are drawn on a billboard, it's nothing less, nothing more<br/>
                    than a sprite which is oriented with the camera.<br/>
                    Here is an example which emit 30 particles per seconds, and have a lifetime of five to seven seconds.<br/>
                    They appear randomly into the rectangle centred at 50, 90, 0 with half-dimentions 25, 5, 0.<br/>
                    They have a velocity of -10, the particles goes above because of the negative force.<br/>
                    The particles here use a random texture rect.
                    <pre>
                        ParticleSystem ps;
                        ps.setTexture(*tm.getResourceByAlias("PARTICLE"));
                        for (unsigned int i = 0; i &lt; 10; i++) {
                            ps.addTextureRect(sf::IntRect(i*10, 0, 10, 10));
                        }
                        UniversalEmitter emitter;
                        emitter.setEmissionRate(30);
                        emitter.setParticleLifetime(Distributions::uniform(sf::seconds(5), sf::seconds(7)));
                        emitter.setParticlePosition(Distributions::rect(Vec3f(50, 90, 0), Vec3f(25, 5, 0)));   
                        // Emit particles in given circle
                        emitter.setParticleVelocity(Distributions::deflect(Vec3f(0, -10, 0),  0)); 
                        // Emit towards direction with deviation of 0°
                        emitter.setParticleRotation(Distributions::uniform(0.f, 0.f));
                        emitter.setParticleTextureIndex(Distributions::uniformui(0, 9));
                        emitter.setParticleScale(Distributions::rect(Vec3f(2.1f, 2.1f, 1.f), Vec3f(2.f, 2.f, 2.f)));
                        ps.addEmitter(emitter);
                    </pre>
                    There is one difference with the thor library, the first is that to remove an emitter you<br/>
                    have to use the removeEmitter method.<br/>
                </p>
                <h2>Billboard</h2>
                <p>
                    In 3D, by default, the particles are drawn at the ground. (this is usefull if you want<br/>
                    to generate particles on the ground.)<br/>
                    But it may not be what you want by example if you want to render smoke, fire, or something like that.<br/>
                    The particle won't face the view, and'll not be correctly rendered.<br/>
                    To correct, that, you can use a billboard, this is just a special entity which'll orient the particles with the view.<br/>
                    You just have a to daw the particule system on the billboard first, and then, draw the billboard<br/>
                    To the render component.<br/>
                    billboard = new BillBoard(view, ps); <br/>
                    Don't forget to update the view and to center the billboad at the <br/>
                    position of the particle system.<br/>
                </p>
            </html>
        </en>
    </content>
</page>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                      <h1>Chapitre II : Création d'une application ODFAEG-LIKE.</h1>

<h2>Définition de l'application : </h2>

<p><br>Pour créer une application « odfaeg-like » il faut hériter de la classe </br> odfaeg::application. (Créer donc une nouvelle classe et faîtes la hériter de <br/> odfaeg::application.)<br/></p>

<p>Si votre application est une application graphique, vous devez appeler le constructeur<br/> de la classe parent (celui de la classe odfaeg::Application) en lui <br/> passant les paramètres suivants : <br/></p>

<pre>
sf::VideoMode, std::string (titre de la fenêtre)
MyAppli(sf::VideoMode wm, std::string title) : Application (wm, title)
</pre>

<p>
Ensuite vous pouvez redéfinir les méthodes suivantes : <br/>

onLoad() <br/>

Méthode à redéfinir si vous avez des ressources externes à charger. <br/>

onInit() <br/>

C'est dans cette méthode que vous créerez et initialiserai tout ce qui doit être <br/> initialiser. (Les commandes, les entités graphiques, la définition des collisions, etc...) <br/>

onRender(odfaeg::FastRenderComponentManager *frcm) <br/>
</p>

<p>
Dans cette méthode vous pouvez définir ce qui devra être dessiné sur la frame courante en <br/> le dessinant sur un composant de rendu ODFAEG. (Le composant de rendu se chargera de <br/> rendre vos dessins de la manière la plus optimale suivant les fonctionnalités <br/> supportées par votre carte graphique) <br/></p>

<p>
Si cette méthode n'est pas redéfinie, ou bien que l'application n'est pas une application <br/> graphique, rien n'est dessiné. <br/>

onDisplay(odfaeg::RenderWindow *window) <br/>

Cette méthode est à redéfinir si vous devez dessiner des choses directement sur la fenêtre <br> de rendu. <br/>

onUpdate(sf::Event&amp; event) <br/> </p>

<p>
Dans cette méthode vous pouvez mettre à jour la frame suivante. (Celle-ci sera mise à jour <br/> en même temps que le dessin de la frame courante à l'aide d'un thread.) <br/>

Ce qui rend le processus de rendu plus rapide. (Si l'application n'est pas une application <br/> graphique ou si cette méthode n'est pas redéfinie, rien n'est remis à jour) <br/>
Cette méthode prend un paramètre : le dernière événement SFML généré par l'application. <br/>

OnExec() <br/></p>

<p>
Cette méthode est à redéfinir si votre application ne possède pas de fenêtre, c'est le cas<br/> par exemple des applications serveur, mais elle peut aussi être redéfinie si votre<br/> application doit effectuer des traitement en fin de boucle.<br/></p>

<h2>Création de l'application : </h2>

<p>
Pour créer une application il suffit d'appeler le constructeur en lui passant les bons <br/> paramètres suivant le type d'application  dans le fonction main : <br/>

MyAppli app(sf::VideoMode(800, 600), "Test odfaeg"); <br/>

Le constructeur de la classe odfaeg::application peut prendre des paramètres <br/> supplémentaires comme par exemple : <br/>

un booléen qui indique si l'on veut activer le depthtest d'opengl ou non. (par défaut ce<br/> boonéen vaut true)<br/>

sf::Style : le style de la fenêtre.<br/>

sf::ContextSettings : permet de spécifier des options de rendu opengl plus détaillées.<br/></p>

<p>
Enfin, pour lancer l'application il suffit d'appeler la méthode exec() de la classe<br/> application, celle-ci renvoie un booléen qui indique si l'application a réussi à s'exécuté <br/> correctement ou si une erreur s'est produite : <br/>

return app.exec() ; <br/>

<h2>Arrêt de l'application : </h2>

<p>
Pour arrêter l'application, il suffit d'appelé la méthode stop dans votre classe qui hérite <br/> de application, par exemple, ici, nous voulons arrêter l'application lorsque <br/> l'utilisateur ferme la fenêtre : <br/>

Nous devons donc rajouter ce code-ci dans la méthode onUpdate : <br/>

<pre>
if (event.type == sf::Event::Closed) {

            stop();
}
</pre>

<p>
Les classes de rendu graphique 2D d'odfaeg sont les même que celle de sfml à l'exception <br/> prêt qu'elles se trouvent dans le namepsace odfaeg et non dans le namespace sf. (Par <br/> exemple odfaeg::ConvexShape pour les formes convexe) <br/>

A la différence de SFML, les objets SFML-LIKE de odfaeg peuvent posséder des points en 3D <br/> pour rendre des entité en 2.5D. (C'est à dire des plans par exemple.) <br/>

Voilà maintenant vous savez créer des applications odfaeg toutes simple. <br/>

                </html>
        </fr>
    </content>
</page>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre X : création d'entités personnalisées. </h1>

               <h2>Création d'un personnage animé : </h2>

<p>Ici nous allons créer un personnage animé à l'aide de tileset contenant les diverses <br/> 
animation de notre personnages dans les directions suivantes : (nord, nord ouest, nord <br/>
est, sud, sud ouest, sud est) <br/>
</p>

<p>
Nous devons d'abord hériter de la classe AnimatedEntity car notre entité personnage est <br/> 
animée, nous allons aussi en profiter pour spécifier des attributs à notre personnage <br/>  
(pour plus tard lorsque l'on créera l'IA du jeux) : <br/>
<pre>
#include &lt;vector&gt;
#ifndef CARACTER
#define CARACTER
#include "odfaeg/Math/vec2f.h"
#include "odfaeg/Graphics/2D/anim.h"
#include &lt;string&gt;
#include &lt;SFML/Graphics.hpp&gt;

class Caracter : public odfaeg::g2d::AnimatedEntity {
    public :
        Caracter (std::string factionName, std::string pseudo, std::string sex, 
        	 std::string currentMapName, std::string hairColor, std::string eyesColor,
        	 std::string skinColor, std::string faceType, std::string classs, int level);
        bool isMovable() const {
            return true;
        }
        bool selectable() const {
            return false;
        }
        bool operator== (Entity&amp; other);
        void addAnimation (odfaeg::g2d::Anim *anim);
        odfaeg::Vec2f getPosition ();
        odfaeg::g2d::Tile&amp; getCurrentTile();
        void setMoving(bool b);
        bool isMoving ();
        void setDir(odfaeg::Vec2f dir);
        odfaeg::Vec2f getDir();
        void setPath(std::vector&lt;odfaeg::Vec2f&gt; path);
        std::vector&lt;odfaeg::Vec2f&gt; getPath();
        int getSpeed();
        void setSpeed(int speed);
        odfaeg::g2d::Anim* getAnimation(unsigned int index);
        unsigned int getCurrentPathIndex ();
        void setCurrentPathIndex (unsigned int index);
        bool isMonster() {
            return false;
        }
        void setRange(int range);
        int getRange();
        void setLife(int life);
        void setMaxLife(int life);
        int getLife ();
        int getMaxLife();
        int getLevel();
        std::string getClass();
        int getAttack();
        void setAttack(int attack);
        void setAttackSpeed(float attackSpeed);
        float getAttackSpeed();
        void setFightingMode(bool b);
        bool isInFightingMode();
        bool isAttacking ();
        void setAlive(bool b);
        bool isAlive();
        void setAttacking(bool b);
        void setCurrentXp(int xp);
        void setXpReqForNextLevel(int xpReqForNextLevel);
        void setLevel (int level);
        sf::Time getTimeOfLastAttack();
        sf::Time getTimeOfLastHpRegen();
        void attackFocusedMonster();
        void up (int xp);
        int getCurrentXp ();
        int getXpReqForNextLevel ();
        float getRegenHpSpeed();
        void setRegenHpSpeed(float regenHpSpeed);
        int getRegenHpAmount();
        void setRegenHpAmount(int regenHpAmount);
        Entity* getCurrentEntity() const;
        void onDraw(odfaeg::RenderTarget&amp;, odfaeg::RenderStates) const;
        virtual ~Caracter();

    private :
        std::string factionName, pseudo, sex, currentMapName, hairColor, 
        eyesColor, skinColor, faceType, classs;
        int level, currentPointIndex, attack, speed, range;
        float attackSpeed, regenHpSpeed;
        bool moving, alive;
        odfaeg::Vec2f dir;
        std::vector&lt;odfaeg::Vec2f&gt; path;
        std::vector&lt;odfaeg::g2d::Anim*&gt; anims;
        int currentAnimIndex;
        int life, maxLife, xp, xpReqForNextLevel, regenHpAmount;
        bool attacking, fightingMode;
        sf::Clock clockAtkSpeed, clockRegenHp;
};
#endif
</pre>
</p>

<p>
Si les attributs sont communs pour tout les types de personnages de notre jeux, alors, <br/>
nous ne sommes pas obligé d'utiliser les states, le cas contraire il est fort <br/>
recommandé d'utilisé des states et du multiple-dispatch afin d'éviter de devoir faire <br/>
trop d'héritage et d'interfaces si on a pleins de type de personnages <br/>
(ou d'armes) différentes et que en plus on définit des règles/des comportements différents <br/>
pour chaque type de personnage ou armes. <br/>
</p>

<p>
Les states et le multiple dispatch sont donc deux bons moyen d'éviter le bordel lorsque le gameplay de votre jeux <br/>
devient plus compliqué. <br/>
</p>

<p>
Bref examinons le fichier .cpp 
<pre>
#include "caracter.h"
#include &lt;iostream&gt;
using namespace std;

using namespace odfaeg;
using namespace odfaeg::g2d;
Caracter::Caracter (string factionName, string pseudo, string sex, string currentMapName, string hairColor,
                  string eyesColor, string skinColor, string faceType, string classs, int level)
    : AnimatedEntity (Vec2f(-50, -25), Vec2f (100, 50), Vec2f(50, 25), "E_CARACTER") {
    currentAnimIndex = 0;
    this->factionName = factionName;
    this->pseudo = pseudo;
    this->sex = sex;
    this->currentMapName = currentMapName;
    this->hairColor = hairColor;
    this->eyesColor = eyesColor;
    this->faceType = faceType;
    this->skinColor = skinColor;
    this->classs = classs;
    this->level = level;
    currentPointIndex = 0;
    speed = 100;
    moving = false;
    dir = Vec2f(0, 1);
    this->life = 100;
    this->maxLife = 100;
    range = 50;
    attackSpeed = 1.f;
    attack = 10;
    fightingMode = attacking = false;
    alive = true;
    xp = 0;
    xpReqForNextLevel = 1500;
    regenHpSpeed = 1.f;
    regenHpAmount = 1;
}
float Caracter::getRegenHpSpeed () {
    return regenHpSpeed;
}
void Caracter::setRegenHpSpeed(float regenHpSpeed) {
    this->regenHpSpeed = regenHpSpeed;
}
sf::Time Caracter::getTimeOfLastHpRegen() {
    return clockRegenHp.getElapsedTime();
}
void Caracter::setLevel(int level) {
    this->level = level;
}
void Caracter::setCurrentXp(int xp) {
    this->xp = xp;
}
void Caracter::setXpReqForNextLevel(int xpReqForNextLevel) {
    this->xpReqForNextLevel = xpReqForNextLevel;
}
void Caracter::up (int xp) {
    this->xp += xp;
    if (this->xp &gt;= xpReqForNextLevel) {
        level++;
        this->xp = this->xp - xpReqForNextLevel;
        xpReqForNextLevel *= 2;
    }
}
int Caracter::getCurrentXp () {
    return xp;
}
int Caracter::getXpReqForNextLevel () {
    return xpReqForNextLevel;
}
void Caracter::setSpeed(int speed) {
    this->speed = speed;
}
int Caracter::getSpeed() {
    return speed;
}
int Caracter::getRegenHpAmount() {
    return regenHpAmount;
}
void Caracter::setRegenHpAmount(int regenHpAmount) {
    this->regenHpAmount = regenHpAmount;
}
void Caracter::setLife(int life) {
    this->life = life;
    clockRegenHp.restart();
}
int Caracter::getLife() {
    return life;
}
void Caracter::setRange(int range) {
    this->range = range;
}
int Caracter::getRange() {
    return range;
}
void Caracter::setAttackSpeed (float attackSpeed) {
    this->attackSpeed = attackSpeed;
}
float Caracter::getAttackSpeed () {
    return attackSpeed;
}
void Caracter::setAttacking(bool b) {

    this->attacking = b;
}
void Caracter::setAlive(bool b) {
    alive = b;
}
bool Caracter::isAlive () {
    return alive;
}
bool Caracter::isAttacking() {
    return attacking;
}
void Caracter::setFightingMode(bool b) {
    this->fightingMode = b;
}
bool Caracter::operator== (Entity &amp;other) {
    if (getType() != other.getType())
        return false;
    Caracter&amp; caracter = static_cast&lt;Caracter&amp;&gt;(other);
    if (anims.size() != caracter.anims.size())
        return false;
    for (unsigned int i = 0; i &lt; anims.size(); i++) {
        if (anims[i] != caracter.anims[i])
            return false;
    }
    return true;
}
bool Caracter::isInFightingMode() {
    return fightingMode;
}
void Caracter::setAttack(int attack) {
    this->attack = attack;
}
int Caracter::getAttack() {
    return attack;
}

sf::Time Caracter::getTimeOfLastAttack() {
    return clockAtkSpeed.getElapsedTime();
}

void Caracter::setDir (Vec2f dir) {

    anims[currentAnimIndex]->setCurrentTile(0);
    float angleRadians = const_cast&lt;Vec2f&amp;&gt;(Vec2f::yAxis).getAngleBetween(dir);
    int angle = Math::toDegrees(angleRadians);
    //Sud
    if (angle &gt;= -10 &amp;&amp; angle &lt;= 10)
        currentAnimIndex = 0;
    //Sud ouest
    else if (angle &gt; -80 &amp;&amp; angle &lt; -10)
        currentAnimIndex = 3;
    //Ouest
    else if (angle &gt;= -100 &amp;&amp; angle &lt;= -80)
        currentAnimIndex = 6;
    //Nord ouest
    else if (angle &gt; -170 &amp;&amp; angle &lt; -100)
        currentAnimIndex = 1;
    //Nors est
    else if (angle &gt; 100 &amp;&amp; angle &lt; 170)
        currentAnimIndex = 7;
    //Est
    else if (angle &gt;= 80 &amp;&amp; angle &lt;= 100)
        currentAnimIndex = 2;
    //Sud est
    else if (angle &gt; 10 &amp;&amp; angle &lt; 80)
        currentAnimIndex = 5;
    else
        currentAnimIndex = 4;

    if (attacking)
        currentAnimIndex += 8;
    this->dir = dir;
}

Vec2f Caracter::getDir () {
    return dir;
}
void Caracter::setMoving (bool b) {
    this->moving = b;
    if (moving) {
        anims[currentAnimIndex]->play(true);
    } else {
        anims[currentAnimIndex]->stop();
        anims[currentAnimIndex]->setCurrentTile(0);
    }

}
bool Caracter::isMoving () {
    return moving;
}

Vec2f Caracter::getPosition () {
    return Vec2f(anims[currentAnimIndex]->getPosition().x, anims[currentAnimIndex]->getPosition().y);
}

void Caracter::setPath(vector&lt;Vec2f&gt; path) {
    this->path = path;
}
vector&lt;Vec2f&gt; Caracter::getPath() {
    return path;
}
void Caracter::addAnimation (Anim *anim) {
    addChild(anim);
    anim->setParent(this);
    anims.push_back(anim);
}
Anim* Caracter::getAnimation(unsigned int index) {
    if (index &gt;= 0 &amp;&amp; index &lt; anims.size())
        return anims[index];
    return NULL;
}
unsigned int Caracter::getCurrentPathIndex() {
    return currentPointIndex;
}
void Caracter::setCurrentPathIndex (unsigned int currentPointIndex) {
    this->currentPointIndex = currentPointIndex;
}

void Caracter::setMaxLife(int life) {
    this->maxLife = maxLife;
}

int Caracter::getMaxLife() {
    return maxLife;
}
int Caracter::getLevel() {
    return level;
}
string Caracter::getClass () {
    return classs;
}
void Caracter::onDraw(RenderTarget &amp;target, RenderStates states) const {
    target.draw(*getCurrentEntity(), states);
}
Entity* Caracter::getCurrentEntity() const {
    return anims[currentAnimIndex]->getCurrentEntity();
}
Caracter::~Caracter() {

}
</pre>
</p>

<p>
Les choses importante à remarqué ici est la redéfinition de la méthode onDraw ou l'on <br/>
dessine la frame courante de l'animation courante du personnage, on change aussi <br/> 
l'animation courante en fonction de la direction du personnage. <br/>
Nous avons aussi les méthodes addChild et setParent lorsque nous ajoutons une animation <br/>
pour notre personnage. <br/>
Ceci à pour conséquence que lorsqu'on dessinera notre personnage il appelera la méthode <br/> 
onDraw des entités enfants et les méthodes onMove, onRotate et onScale ce qui aura pour <br/> 
conséquence de dessiner aussi les entités enfants de l'entité (c'est à dire l'entité  <br/> 
courante de l'animation courante ici) lorsqu'on dessinera l'entité toutes les entités <br/> 
enfants seront transformées par rapport à la transformation de l'entité parent. <br/> 
(c'est à dire toutes les frames des animations du personnages) <br/>
</p>

<p>
Si vous devez remettre des données à jour lorsque le personnage bouge ou bien si vous <br/>
voulez modifier la transformation vous pouvez redéfinir la méthode onMove en <br/>
n'oubliant pas d'appelé la méthode move de la classe de base Entity en lui passant la <br/>
transformation si vous voulez que les transformations se combinent avec celles de l'entité <br/>
parent : <br/>

<pre>
void Caracter::onMove(Vec3f t) {
	Entity::onMove(t) ;
           //Mise à jour des autres informations. (La physique par exemple)
        if (getCollisionVolume() != nullptr) {
		getCollisionVolume()->move(Vec3f(t.x, t.y, 0));
    	}
}
</pre>
</p>

<p>
Ici nous avons un vector en 3D, il faut savoir que pour les entités ODFAEG en 2D la <br/>
position en z de l'entité est égale à son centre en y, sa translation en z sera donc la <br/>
même que celle en y. <br/>
Par contre pour la physique, pas besoin du z.<br/>
</p>

<p>
Si vous ne voulez pas que la translation se combine avec les entités enfants, vous pouvez laisser cette méthode vide. <br/>

Vous pouvez effectuer la même chose pour la rotation et le changement d'échelle en <br/>
redéfinissant les méthodes onRotate et onScale. <br/>

ODFAEG possède 5 classes de bases dont peuvent hériter toutes vos entités personnalisées : <br/>
</p>

<p>
Entity pour les entités de base qui n'ont pas d'ombre ni d'intersections avec la lumière. <br/>
(Par exemple les tiles) <br/>

Model : pour les entités qui possèdent une ombre et qui peuvent avoir des intersections <br/> 
avec la lumière et une ombre : (Par exemple les murs et les décors) <br/>

AnimatedEntity : pour toutes les entités animées. <br/>

Shadow : pour toutes les entités qui sont des ombres. <br/>

Light : pour toutes les entités qui sont des lumières. <br/>
</p>

<p>
Et enfin pour transformer une entité, nous devons appeler la méthode move de la classe <br/> 
World, ceci aura pour effet de mettre à jour également l'entité dans la grille gu gestionnaire d'entité en fonction <br/> 
de son rectangle englobant : <br/>

World::moveEntity(caracter, caracter->getDir().x * t, caracter->getDir().y * t);<br/>
</p>
                </html>
        </fr>
        <en>
        	<html>
        		<h1>Chapter VII : the 2D entity management system and the components.</h1>
        		<h2>Storing entities in the manager.</h2>
        		<p>
        		To store entities in the entity manager, you just have to create an object of type map.<br/>
        		The map class if the default entity manager of ODFAEG, but, you can also create <br/>
        		your own entity manager if the default one doesn't feed your needs.<br/>
        		For that, you just have to inherit from the entity manager class and redefines <br/>
        		some methods.<br/>
        		The default entity manager store every entities into a grid, and the grid is auto-resized <br/>
        		depending on the map size, coordinate system of the grid can be changed with a base changement matrix.<br/>
        		You can also specify the width and the height of the grid, the depth is not needed, because, <br/>
        		opengl performs already a clipping between the znear and zfar plane.<br/>
        		ODFAEG use also a base changement matrix to change the world coordinates landmark.<br/>
        		The base changement matrix allow you to defines entities coordinates in another landmark <br/>
        		than the one used by odfaeg to render the scene.<br/>
        		<br/>
        		</p>
        		<p>
        		The more popular case is the case of 3D isometric games.<br/>
        		The word coordinates are in a 3D isometric landmark but the view coordinates are in a <br/>
        		2D landmark.<br/>
        		To change the base changement matrix, create a BaseChangementMatrix and pass it to the entity manager.<br/>
        		The scene can be rendered to one or more render components, or on the render window.<br/>
        		The first parameter to pass if the render component manager, the entity manager need it.<br/>
        		to render the scene on the components.<br/>
        		The second parameter is an identifiant of the entity manager, ODFAEG can store several entity managers.<br/>
        		This is very usefull for games with a big world, you can generate several terrains; add them <br/>
        		to the components, and draw the scene of each visible terrains.<br/>
        		theMap = new Map(&getRenderComponentManager(), "Map test", 100, 50); <br/>
        		width and height are the dimentions of the cells of the grid for the map.<br/>
        		</p>
        		<p>
        		For performance purpose, odfaeg don't provide a quadtree or a bsp-tree structure to store entities.<br/>
        		You can use several entity managers (so it'll create several grids) if the entities are very close to other ones.<br/>
        		It avoids to have to reconstruct all the tree everytime that an entity has moved.<br/>
        		To add and change current active entity manager, you can use those functions : <br/>
        		<pre>
        		World::addEntityManager(theMap);
			World::setCurrentEntityManager("Map");
			</pre>
			The world have the big advantage to allow you to store several entity managers, to add entities to them<br/>
			and to render entities from different entity managers into the components.
			</p>
			<h2>Drawing entities : </h2>
			<p>
			To draw entities with ODFAEG, you'll need to create render components, and to call the drawOnComponents<br/>
			method of the World class.<br/>
			The constructor of the render component attempts three parameters.<br/>
			The first is the render window.<br/>
			The second is the id of the components, it'll also define the order in which components'll be drawn.<br/>
			The last parameters is the group of entities to draw at the next frame.<br/>
			There is also a last default parameter which indicates if we want to use a thread to render the entities on the component<br/>
			or not.<br/>
			By default this parameter is set to false.<br/>
			Then you need to add the component into the component manager : <br/>
			<pre>
			FastRenderComponent* frc1 = new FastRenderComponent(getRenderWindow(), 0, "E_BIGTILE");
			FastRenderComponent* frc2 = new FastRenderComponent(getRenderWindow(), 1, "E_WALL+E_DECOR+
			E_ANIMATION+E_CARACTER");
			getRenderComponentManager().addRenderComponent(frc1);
			getRenderComponentManager().addRenderComponent(frc2);
			</pre>
			</p>
			Than you need to defines which entities to render at each frame, this is done by calling the<br/>
			drawOnComponents method of the world class : <br/>
			The first parameter are the group of entities to draw, the second is the id of the component on which we want to draw the entities.<br/>
			<pre>
			World::drawOnComponents("E_BIGTILE", 0);// draw everything here...
			World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);
			</pre>
			The + means that we want to render more than one groupe of entities.<br/>
			So here we want to render the group E_BIGTILE on the component 0 and E_WALL, E_DECOR, E_ANIMATION and E_CARACTER <br/>
			on the first components.<br/>
			The entity manager have also a lot of usefull methods : <br/>
			World::generate_map to generate a random terrain : <br/>
			The first parameter is the tiles of the ground used to generate the terrain.<br/>
			The second parameter is a set of tiles used if we want to set walls arount the terrain.<br/>
			The thirst parameter is the size of a square of the terrain.<br/>
			The fourth parameter is the zone where we want to generate the terrain.<br/>
			And the last parameter indicates if we want to generate a 2D or a 3D terrain.<br/>
			getLightMap to get the lightmap.<br/>
			The lightmap is where every lights are rendered, and then there are rendered with<br/>
			the sf::BlendMultiply mode over the window.<br/>
			The first parameter is the group of lights to render on the lightmap.<br/>
			The second parameter is the number of render components used to render the lightmap.<br/>
			And the last one is a variadic parameter which are the ids of components which are in intersection with the light.<br/>
			By example, the component drawing the terrain doen't intersect with the light.<br/>
			Remember that odfaeg use the z component of each tiles to know if a tile is before or behind another one, and to clip the entities so<br/>
			if the z component of the terrain's fragment is greater than the z component of the fragment's light, <br/>
			the light fragment won't be displayed and it'll give bad results.<br/>
			Because in reality the terrain is flat, the z must not be used to check collision for the terrain with the light.<br/>
			This is also not necessary to compute lighting with the normals because the terrain is flat so each normals are<br/>
			pointing in the up direction!<br/>
			So you need to tell to odfaeg to don't check the interections and to don't compute the normals with the light<br/>
			for the component which draw the ground.<br/>
			So, we pass 1 because this is the only component which draw entities that can intersects whith the lighmap!<br/>
			getShadowMap to get the shadow map.
			The first parameter is the group of entities for which we want to generate shadows.
			The second parameters and the last parameter are the same meanins than the lightmap, this is not<br/>
			necessary to generate shadows for the tiles of the terrain.<br/>
			Only models can generate a shadow. (so, each entities which inherits from the model class)<br/>
			The view is placed to the lights position, and them, the stencil buffer is used to check where <br/>
			the shadows fragment have to be generated, but those shadows may not be correctly centered.<br/>
			The models have a shadow matrix to transform the generate shadows which are rendered onto the sahdow map.<br/>
			This matrix can be modified to center the shadows for example by calling the setShadowCenter method.<br/>
			This'll perform a translation of the shadows on the ground to center them.<br/>
			The getPath function allow you to get the path between two entities of the world.<br/>
			In the next version, you'll be able to also get 3D paths.<br/>
			By example, this'll get the path from an entity to the mouse position : <br/>
			<pre>
			Vec2f mouse(mousePos.x, mousePos.y);
			Vec3f finalPos = getRenderWindow().mapPixelToCoords(Vec3f(mouse.x, mouse.y, 0));
			std::vector<Vec2f> path = World::getPath(caracter, finalPos);
			</pre>
			The function collide allow you to check if an entity is in collision which the world at this place. <br/>
			And finally, the update function allow you the update the entities.<br/>
        	</html>
        </en>
    </content>
</page>

<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre VII : Le système de gestion d'entités 2D et 2.5D et les composants :  </h1>

                Stocker des entités dans le gestionnaire :

Pour stocker des entités dans le gestionnaire il suffit de créer un objet de type map, les gestionnaires d'entités contiennent une grille et les entités sont stockées dans les cellules de cette grille, la grille s'agrandis et se rétréci en fonction de la taille de la map, les cellules de la grille peuvent être définie à l'aide d'une matrice de changement de base ainsi que d'une largeur, d'une hauteur et d'une profondeur pour la 3D.

La matrice de changement de base est utile si les entités ont été rendues dans un autre repère (avec un autre logiciel) que celui utilisé par l'application. (C'est le cas par exemple pour les jeux en 3D isométrique, les objects sont rendus dans un repère en 3D sur une image en 2D et l'application rend ses images dans un repère en 2D) 
On peut aussi utiliser cette matrice si l'on veut stocker les entités dans un autre repère que celui utilisé par opengl.

Le gestionnaire d'entité va alors changé de repère lors de la création des cellules de la grille suivant la matrice de changement de base.

Les entités seront donc placée dans une grille qui est contenue dans un repère en 3D isométrique par exemple. (tandit que les entités seront dessinées dans un repère en 2D)

Par défaut la grille contient la matrice de changement de base en 3D iso mais on peut la changer en créant une instance de BaseChangementMatrix et en la passant au gestionnaire d'entité.
La scène peut être rendu sur un ou plusieurs composants de rendu, ces composants choisissent la meilleur option de rendu suivant les fonctionnalités supportée par votre carte graphique. (Shaders, etc...)

Pour créer un gestionnaire d'entité il suffit d'appeler cette fonction : 

theMap = new Map(&amp;getRenderComponentManager(), "Map test", 100, 50, 0);

En lui passant le gestionnaire de composant de rendu utilisé par l'application.

Le gestionnaire de composant contiendra et dessinera tout composants utilisé par l'application (composants de rendu de la scene, guis (menus, ...), shadowMap, LightMap, etc....)
On passe ensuite le nom de la map, ainsi que la largeur, la hauteur et la profondeur des cellules de la grille.

Il n'est pas possible d'utiliser un quadtree ou un bsp-tree simplement avec odfaeg (à moins de créer son propre gestionnaire d'entité en héritant de la classe g2d ::EntityManager pour la simple et bonne raison que odfaeg veut rester dans la simplicité et une grille est plus facile à gérer dans le cadre du pathfinding et afin de permettre la création d'une map de n'importe quelle taille sans devoir tout régénérer.

Un quadtree nécessite de connaitre la taille de la map à l'avance et un bsp-tree nécessite d'être construit à l'avance avec un éditeur de map.

Il a fallut donc trouvé une alternative et la meilleur que j'ai pu trouvée c'est celle-ci :

Ne travailler que avec des coordonnées entières (et donc pas de coordonnées flottantes qui causes en général des problèmes lors des calculs. (qui doivent être réglé avec un epsilon) 

Utiliser plusieurs gestionnaires d'entités avec divers tailles pour les cellules de la grille si les objects sont vraiment très proche les uns des autres, ou bien si le monde est très grand, et stocker ses gestionnaire d'entités dans une classe.

La classe qui permet de stocker ses gestionnaires d'entités s'appelle world et on peut ajouté et récupérer des gestionnaires d'entité comme ceci (il ne faut pas non plus oublier de définir avec quel gestionnaire d'entité on veut travaillé grâce à la méthode setCurrentEntityManager)

World::addEntityManager(theMap);
World::setCurrentEntityManager("Map test");

Le monde à l'avantage de pouvoir stocker des gestionnaires d'entités pour les entités en 2D et 2.5D mais aussi plus tard pour les entités en 3D.

Ensuite pour ajouté une entité dans le monde il suffit d'appeler la méthode addEntity de la classe World : 
World::addEntity(myEntity) ;

Dessiner des entités :

Pour dessiner des entités ODFAEG il suffit d'appelé la méthode drawOnComponents de la classe world : en lui passant le type d'entité que l'on veut dessiner, comme ceci :

World::drawOnComponents("E_TILE", 0);// draw everything here...
World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);

Le 1er paramètre est le type d'entité à dessiner sur le composant, le second paramètre est la position en z du composant sur lequel on veut dessiner la scène.

0 = le composant du fond.
1 = le composant du dessus.

Remettre à jour les entités : 

Pour remettre à jour les entités odfaeg possède 2 classes, une classe EntityUpdater qui remet à jour les entités présente de la vue passée à la fenêtre de rendu, et AnimUpdater pour remettre à jour la frame courante des animations, il suffit de créer ces deux objets et de les ajouter à notre monde pour remettre à jour la frame couante : (setInterval permet de définir la fréquence avec laquelle le thread va remettre à jour la frame courante des différentes animations.)

eu = new EntitiesUpdater();       
 World::addEntitiesUpdater(eu);
 au = new AnimUpdater();
 au->setInterval(seconds(0.01f));

Si votre monde possède des lumières, n'oublier pas d'appeler la méthode computeIntersectionsWithWalls de la classe World , pour rendre les ombres et les lumières, il suffit d'appeler la méthode getShadowMap de la classe World, voici donc par exemple comment tracer une scene dans la méthode onRender :
odfaeg::World::drawOnComponents("E_BIGTILE", 0);
        odfaeg::World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);
odfaeg::RenderStates states(sf::BlendMode(sf::BlendMultiply));
odfaeg::g2d::Entity& shadowMap = odfaeg::World::getShadowMap<odfaeg::g2d::Entity>();
odfaeg::World::drawOnComponents(shadowMap, 0, states);

Et voici un exemple de code qui met à jour les entités dans la méthode onUpdate() :

                </html>
        </fr>
    </content>
</page>

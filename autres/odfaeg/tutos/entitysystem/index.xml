<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="/xsl/structure.xsl"?>
<page>
    <menu>/autres/odfaeg/xml/menu.xml</menu>
    <footer>/autres/odfaeg/xml/footer.xml</footer>
    <title>ODFAEG</title>
    <content>
        <fr>
                <html>
                        <h1>Chapitre VII : Le système de gestion d'entités 2D et 2.5D et les composants : </h1>

                <h2>Stocker des entités dans le gestionnaire : </h2>

<p>
Pour stocker des entités dans le gestionnaire il suffit de créer un objet de type map, <br/>
La classe map est le gestionnaire d'entité par défaut de ODFAEG, mais on peut créer son propre gestionnaire.<br/>
Le gestionnaire d'entité par défaut contient une grille et les entités sont stockées dans <br/>
les cellules de cette grille, la grille s'agrandis et se rétréci en fonction de la <br/>
taille de la map, les cellules de la grille peuvent être définie à l'aide d'une <br/>
matrice de changement de base ainsi que d'une largeur et d'une hauteur <br/> 
</p>

<p>
La matrice de changement de base est utile si les entités ont été rendues dans un autre<br/> 
repère (avec un autre logiciel) que celui utilisé par l'application. (C'est le <br/> 
cas par exemple pour les jeux en 3D isométrique, les objects sont rendus dans un <br/>
repère en 3D sur une image en 2D et l'application rend ses images dans un repère en 2D) <br/> 
On peut aussi utiliser cette matrice si l'on veut stocker les entités dans un autre repère <br/> 
que celui utilisé par opengl. <br/>
</p>

<p>
Le gestionnaire d'entité va alors changé de repère lors de la création des cellules de <br/> 
la grille suivant la matrice de changement de base.<br/>

Les entités seront donc placée dans une grille qui est contenue dans un repère en 3D <br/> 
isométrique par exemple. (tandit que les entités seront dessinées dans un repère en 2D) <br/>

Par défaut la grille contient la matrice de changement de base en 3D iso mais on peut la <br/>
changer en créant une instance de BaseChangementMatrix et en la passant au <br/>
gestionnaire d'entités. <br/>
La scène peut être rendu sur un ou plusieurs composants de rendu, ces composants <br/>
choisissent la meilleur option de rendu suivant les fonctionnalités supportée par votre <br/>
carte graphique. (Shaders, etc...) <br/>
</p>

<p>
Pour créer un gestionnaire d'entité il suffit d'appeler cette fonction : <br/>

theMap = new Map(&amp;getRenderComponentManager(), "Map test", 100, 50); <br/>

En lui passant le gestionnaire de composant de rendu utilisé par l'application. <br/>

Le gestionnaire de composant contiendra et dessinera tout composants utilisé par <br/>
l'application (composants de rendu de la scene et guis) <br/>
On passe ensuite le nom de la map, ainsi que la largeur et la hauteur des <br/>
cellules de la grille. <br/>
</p>

<p>
Il n'est pas possible d'utiliser un quadtree ou un bsp-tree simplement avec odfaeg (à 
<br/> moins de créer son propre gestionnaire d'entité en héritant de la classe <br/> 
g2d ::EntityManager pour la simple et bonne raison que odfaeg veut rester dans la <br/> 
simplicité et une grille est plus facile à gérer dans le cadre du pathfinding et afin de <br/> 
permettre la création d'une map de n'importe quelle taille sans devoir tout régénérer. <br/>
</p>

<p>Un quadtree nécessite de connaitre la taille de la map à l'avance et un bsp-tree <br/> 
nécessite d'être construit à l'avance avec un éditeur de map. <br/>

Il a fallut donc trouvé une alternative et la meilleur que j'ai pu trouvée c'est celle-ci : <br/>
</p>

<p>
Utilisez plusieurs gestionnaires d'entités avec divers tailles pour les cellules de la <br/>
grille si les objects sont vraiment très proche les uns des autres, ou bien si le <br/>
monde est très grand, et stocker ses gestionnaires d'entités dans la classe "world" qui constitue tout le monde du jeux. <br/>
</p>

<p>La classe qui permet de stocker ses gestionnaires d'entités s'appelle world et on peut <br/>
ajouté et récupérer des gestionnaires d'entité comme ceci (il ne faut pas non plus <br/>
oublier de définir avec quel gestionnaire d'entité on veut travaillé grâce à la méthode setCurrentEntityManager)<br/>
<pre>
World::addEntityManager(theMap);
World::setCurrentEntityManager("Map test");
</pre>
</p>

<p>
Le monde à l'avantage de pouvoir stocker des gestionnaires d'entités pour les entités en <br/> 
2D et 2.5D mais pour les entités en 3D. <br/>

Ensuite pour ajouté une entité dans le monde il suffit d'appeler la méthode addEntity de la <br/> 
classe World : <br/>
World::addEntity(myEntity); <br/>
</p>
Les entités et les gestionnaires d'entités seront automatiquement détruit quand le monde sera détruit c'est à dire,<br/>
tout à la fin de l'exécution du programme. (Juste après la destruction de la fenêtre)<br/>

<h2>Dessiner des entités : </h2>

<p>
Pour dessiner des entités ODFAEG il suffit de créer des composants de rendu et d'appeler la méthode drawOnComponents de la <br/> 
classe world : en lui passant le type d'entité que l'on veut dessiner, comme ceci : <br/>

<pre>
//Dans onInit :
FastRenderComponent* frc1 = new FastRenderComponent(getRenderWindow(), 0, "E_BIGTILE");
FastRenderComponent* frc2 = new FastRenderComponent(getRenderWindow(), 1, "E_WALL+E_DECOR+
E_ANIMATION+E_CARACTER");
getRenderComponentManager().addRenderComponent(frc1);
getRenderComponentManager().addRenderComponent(frc2);
//Et dans onRender :
World::drawOnComponents("E_BIGTILE", 0);// draw everything here...
World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);
</pre>
</p>

<p>
Lors de la création du composant il faut lui passer la fenêtre de rendu, l'id du composant (c'est l'ordre dans lequel sera dessiner le composant)<br/>
0 signifie que le composant sera dessiné en 1er.<br/>
Le 3ème paramètre est le type d'entité à dessiner sur le composant à la frame suivante et le dernier paramètre. <br/>
qui est facultatif, indique si l'on veut utiliser un thread pour le rendu du composant.
Ensuite il faut ajouter les composants de rendu dans le gestionnaire de composant avec la méthode addRenderComponent.<br/>
Dans la méthode onRender il ne faut pas oublier de remettre à jour la framesuivante en indique le type d'entités à dessiné.<br/>
sur les composants en appelant la méthode drawOnComponents de la classe World! <br/>
Le 1er paramètre est le type des entités à dessiner, et le second, l'id du composant de rendu.<br/>

0 = le composant du fond. <br/>
1 = le composant du dessus. <br/>

Le gestionnaire d'entité possède aussi un tas d'autre fonctions très pratiques : <br/>
World::generate_map pour générer un terrain aléatoirement. <br/>
Le 1er paramètre sont les tiles du sol utilisées pour générer le terrain.<br/>
Le second paramètres sont les tiles du mure utilisée pour généré le bord du terrain.<br/>
Le 3ème paramètre est la taille d'un carré sur le terrain.<br/>
Le 4ème paramètre est la zone dans laquelle générer le terrain.<br/>
Le dernier paramètre indique si il faut générer un terrain en 2D ou bien en 3D. <br/>
<br/>
getLightMap et getShadowMap pour récupérer la lightmap et la shadowmap : <br/>
Entity&amp; shadowMap = World::getShadowMap("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 2, 1); <br/>
Le 1er paramètre est le type des entités pour lesquels générer une ombre.<br/>
Le seconds est le nombre de composants de rendus.<br/>
Le troisième est variable, ce sont les ids des composants en intersection avec la lumière.<br/>
Rien ne sert de générer d'ombres pour le composant qui dessine le sol.<br/>
getLightMap fonctionne de la même manière.<br/>
Pour dessiner la shadowmap sur un composant ont peut faire ceci : <br/>
RenderStates states(sf::BlendMode(sf::BlendMultiply)); <br/>
Entity&amp; shadowMap = World::getShadowMap("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 2, 1); <br/>
World::drawOnComponents(shadowMap, 0, states); <br/>
On peut passer des paramètres de rendu différent, par exemple ici j'utilise un blend multiply pour<br/>
Dessiner la shadow map sur le composant du sol.<br/>
<br/>
La fonction getPath permet de récupérer le chemin entre 2 entités, pour l'instant seul un chemin en 2D <br/>
peut être récupérer mais dans la version suivant on pourra aussi récupérer un chemin en 3D. <br/>
Par exemple ceci permet de récupérer la chemin entre une entité et la position de la souris :
Vec2f mouse(mousePos.x, mousePos.y); <br/>
Vec3f finalPos = getRenderWindow().mapPixelToCoords(Vec3f(mouse.x, mouse.y, 0)); <br/>
std::vector&lt;Vec2f&gt; path = World::getPath(caracter, finalPos);<br/>
<br/>
La fonction collide permet de tester si une entité est en collision avec le monde : <br/>
World::collide(caracter)<br/>
<br/>
Et enfin la fonction update permet de remettre à jour le monde. <br/>
</p>

<h2>Remettre à jour les entités : </h2>

<p>Pour remettre à jour les entités odfaeg possède 2 types de classes, des workers et des timers<br/>
Tout les worker héritent de la classe EntitySystem et les timers de la classe Timer<br/>
La différence entre les deux est que les timers remettent à jour les entités tout les x interval de temp.<br/>
Et les workers remettent à jour les entités à un temps donné.<br/>
La classe EntityUpdater qui hérite de la classe EntitySystem est le worker par défaut, celui-ci <br/>
remet à jour les entités présente dans les vues de la fenêtre de rendu, et des composants de rendu.<br/>
AnimUpdater est le timer par défaut qui remet à jour la frame courante des animations, il suffit de créer ces <br/>
deux objets et de les ajouter à notre monde pour remettre à jour les entités de la frame suivante.<br/>
setInterval permet de définir la fréquence avec laquelle le timer va remettre à jour la <br/>
frame courante des différentes animations.) <br/>

<pre>
eu = new EntitiesUpdater();       
 World::addEntitiesUpdater(eu);
 au = new AnimUpdater();
 au->setInterval(seconds(0.01f));
 World::addAnumUpdater(au);
</pre>
</p>

<p>
Et voici un exemple de code qui met une entité à jour :
<pre>
if (caracter->isMoving()) {
            if (caracter->isMovingFromKeyboard()) {
                odfaeg::World::moveEntity(caracter, caracter->getDir().x * t * caracter->getSpeed(), 
                caracter->getDir().y * t * caracter->getSpeed(),caracter->getDir().y * t * 
                caracter->getSpeed());
                if (odfaeg::World::collide(caracter)) {
                    odfaeg::World::moveEntity(caracter, -caracter->getDir().x * t * caracter->getSpeed(), 
                    -caracter->getDir().y * t * caracter->getSpeed(),-caracter->getDir().y * t *
                    caracter->getSpeed());
                }
                odfaeg::Vec3f d = caracter->getCenter() - getView().getPosition();
                getView().move(d.x, d.y, d.y);
                odfaeg::World::update();
</pre>
</p>
<p>Il ne faut pas oublier d'appeler la méthode World::update() pour mettre à jour la frame <br/>
suivante si l'on se déplace dans le monde. 
Et voilà, ceci clôture ce chapitre plutôt long mais très important.<br/>
</p>
                </html>
        </fr>
        <en>
        	<html>
        		<h1>Chapter VII : the 2D entity management system and the components.</h1>
        		<h2>Storing entities in the manager.</h2>
        		<p>
        		To store entities in the entity manager, you just have to create an object of type map.<br/>
        		The map class if the default entity manager of ODFAEG, but, you can also create <br/>
        		your own entity manager if the default one doesn't feed your needs.<br/>
        		For that, you just have to inherit from the entity manager class and redefines <br/>
        		some methods.<br/>
        		The default entity manager store every entities into a grid, and the grid is auto-resized <br/>
        		depending on the map size, coordinate system of the grid can be changed with a base changement matrix.<br/>
        		You can also specify the width and the height of the grid, the depth is not needed, because, <br/>
        		opengl performs already a clipping between the znear and zfar plane.<br/>
        		ODFAEG use also a base changement matrix to change the world coordinates landmark.<br/>
        		The base changement matrix allow you to defines entities coordinates in another landmark <br/>
        		than the one used by odfaeg to render the scene.<br/>
        		<br/>
        		</p>
        		<p>
        		The more popular case is the case of 3D isometric games.<br/>
        		The word coordinates are in a 3D isometric landmark but the view coordinates are in a <br/>
        		2D landmark.<br/>
        		To change the base changement matrix, create a BaseChangementMatrix and pass it to the entity manager.<br/>
        		The scene can be rendered to one or more render components, or on the render window.<br/>
        		The first parameter to pass if the render component manager, the entity manager need it.<br/>
        		to render the scene on the components.<br/>
        		The second parameter is an identifiant of the entity manager, ODFAEG can store several entity managers.<br/>
        		This is very usefull for games with a big world, you can generate several terrains; add them <br/>
        		to the components, and draw the scene of each visible terrains.<br/>
        		theMap = new Map(&amp;getRenderComponentManager(), "Map test", 100, 50); <br/>
        		width and height are the dimentions of the cells of the grid for the map.<br/>
        		</p>
        		<p>
        		For performance purpose, odfaeg don't provide a quadtree or a bsp-tree structure to store entities.<br/>
        		You can use several entity managers (so it'll create several grids) if the entities are very close to other ones.<br/>
        		It avoids to have to reconstruct all the tree everytime that an entity has moved.<br/>
        		To add and change current active entity manager, you can use those functions : <br/>
        		<pre>
        		World::addEntityManager(theMap);
			World::setCurrentEntityManager("Map");
			</pre>
			The world have the big advantage to allow you to store several entity managers, to add entities to them<br/>
			and to render entities from different entity managers into the components.
			</p>
			<h2>Drawing entities : </h2>
			<p>
			To draw entities with ODFAEG, you'll need to create render components, and to call the drawOnComponents<br/>
			method of the World class.<br/>
			The constructor of the render component attempts three parameters.<br/>
			The first is the render window.<br/>
			The second is the id of the components, it'll also define the order in which components'll be drawn.<br/>
			The last parameters is the group of entities to draw at the next frame.<br/>
			There is also a last default parameter which indicates if we want to use a thread to render the entities on the component<br/>
			or not.<br/>
			By default this parameter is set to false.<br/>
			Then you need to add the component into the component manager : <br/>
			<pre>
			FastRenderComponent* frc1 = new FastRenderComponent(getRenderWindow(), 0, "E_BIGTILE");
			FastRenderComponent* frc2 = new FastRenderComponent(getRenderWindow(), 1, "E_WALL+E_DECOR+
			E_ANIMATION+E_CARACTER");
			getRenderComponentManager().addRenderComponent(frc1);
			getRenderComponentManager().addRenderComponent(frc2);
			</pre>
			</p>
			<p>
			Than you need to defines which entities to render at each frame, this is done by calling the<br/>
			drawOnComponents method of the world class : <br/>
			The first parameter are the group of entities to draw, the second is the id of the component on which we want to draw the entities.<br/>
			<pre>
			World::drawOnComponents("E_BIGTILE", 0);// draw everything here...
			World::drawOnComponents("E_WALL+E_DECOR+E_ANIMATION+E_CARACTER", 1);
			</pre>
			The + means that we want to render more than one groupe of entities.<br/>
			So here we want to render the group E_BIGTILE on the component 0 and E_WALL, E_DECOR, E_ANIMATION and E_CARACTER <br/>
			on the first components.<br/>
			The entity manager have also a lot of usefull methods : <br/>
			World::generate_map to generate a random terrain : <br/>
			The first parameter is the tiles of the ground used to generate the terrain.<br/>
			The second parameter is a set of tiles used if we want to set walls arount the terrain.<br/>
			The thirst parameter is the size of a square of the terrain.<br/>
			The fourth parameter is the zone where we want to generate the terrain.<br/>
			And the last parameter indicates if we want to generate a 2D or a 3D terrain.<br/>
			getLightMap to get the lightmap.<br/>
			The lightmap is where every lights are rendered, and then there are rendered with<br/>
			the sf::BlendMultiply mode over the window.<br/>
			The first parameter is the group of lights to render on the lightmap.<br/>
			The second parameter is the number of render components used to render the lightmap.<br/>
			And the last one is a variadic parameter which are the ids of components which are in intersection with the light.<br/>
			By example, the component drawing the terrain doen't intersect with the light.<br/>
			Remember that odfaeg use the z component of each tiles to know if a tile is before or behind another one, and to clip the entities so<br/>
			if the z component of the terrain's fragment is greater than the z component of the fragment's light, <br/>
			the light fragment won't be displayed and it'll give bad results.<br/>
			Because in reality the terrain is flat, the z must not be used to check collision for the terrain with the light.<br/>
			This is also not necessary to compute lighting with the normals because the terrain is flat so each normals are<br/>
			pointing in the up direction!<br/>
			</p>
			<p>
			So you need to tell to odfaeg to don't check the interections and to don't compute the normals with the light<br/>
			for the component which draw the ground.<br/>
			So, we pass 1 because this is the only component which draw entities that can intersects whith the lighmap!<br/>
			getShadowMap to get the shadow map.
			The first parameter is the group of entities for which we want to generate shadows.
			The second parameters and the last parameter are the same meanins than the lightmap, this is not<br/>
			necessary to generate shadows for the tiles of the terrain.<br/>
			Only models can generate a shadow. (so, each entities which inherits from the model class)<br/>
			The view is placed to the lights position, and them, the stencil buffer is used to check where <br/>
			the shadows fragment have to be generated, but those shadows may not be correctly centered.<br/>
			The models have a shadow matrix to transform the generate shadows which are rendered onto the sahdow map.<br/>
			This matrix can be modified to center the shadows for example by calling the setShadowCenter method.<br/>
			This'll perform a translation of the shadows on the ground to center them.<br/>
			The getPath function allow you to get the path between two entities of the world.<br/>
			In the next version, you'll be able to also get 3D paths.<br/>
			By example, this'll get the path from an entity to the mouse position : <br/>
			<pre>
			Vec2f mouse(mousePos.x, mousePos.y);
			Vec3f finalPos = getRenderWindow().mapPixelToCoords(Vec3f(mouse.x, mouse.y, 0));
			std::vector&lt;Vec2f&gt; path = World::getPath(caracter, finalPos);
			</pre>
			The function collide allow you to check if an entity is in collision which the world at this place. <br/>
			And finally, the update function which update the scene, by example, when the view has changed.<br/>
			</p>
			<h2>Update the entities.</h2>
			<p>
			To update the entities, odfaeg have two types of classes, workers and timers.<br/>
			Every workers inherits from the EntitySystem class and every timer from the timer class.<br/>
			The difference between both are that the timers set the entities up to date at each interval of<br/>
			time, but, workers perform a tast only at a precise moment. (By example, when view has changed)<br/>
			The class EntityUpdater is an entity system, this is the default worker of ODFAEG, and it<br/>
			check every entities which are in the field of the views. (for each render components)<br/>
			The AnimUpdater class is the default class of the animation updaters.<br/>
			To update the entities you need to create an entity system and a timer to update animations<br/>
			and then, add them to the world.<br/>
			<pre>
			eu = new EntitiesUpdater();       
			World::addEntitiesUpdater(eu);
			au = new AnimUpdater();
			au->setInterval(seconds(0.01f));
			World::addAnumUpdater(au);
			</pre>
			Here is an example of source code which update an entity.<br/>
			<pre>
				if (caracter->isMoving()) {
			            if (caracter->isMovingFromKeyboard()) {
			                odfaeg::World::moveEntity(caracter, caracter->getDir().x * t * caracter->getSpeed(), 
			                caracter->getDir().y * t * caracter->getSpeed(),caracter->getDir().y * t * 
			                caracter->getSpeed());
			                if (odfaeg::World::collide(caracter)) {
			                    odfaeg::World::moveEntity(caracter, -caracter->getDir().x * t * caracter->getSpeed(), 
			                    -caracter->getDir().y * t * caracter->getSpeed(),-caracter->getDir().y * t *
			                    caracter->getSpeed());
			                }
			                odfaeg::Vec3f d = caracter->getCenter() - getView().getPosition();
			                getView().move(d.x, d.y, d.y);
			            }
			        }
        			odfaeg::World::update();
			</pre>
			The method world::update() call the worker which updates entities which are of the field of view <br/>
			of the camera.<br/>
			And that's it! 
			This is how the powerfull entity system of ODFAEG works!
			</p>
        	</html>
        </en>
    </content>
</page>
